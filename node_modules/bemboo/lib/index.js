"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.blockMaker = exports.wrapClass = exports.wrapFunction = exports.Block = exports.create = exports.disableCache = exports.resetCache = exports.cache = exports.defaultSettings = void 0;

var _shallowequal = _interopRequireDefault(require("shallowequal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defaultSettings = {
  namespace: '',
  elementDelimiter: '__',
  modifierDelimiter: '--',
  modifierValueDelimiter: '-'
};
exports.defaultSettings = defaultSettings;
var cache = {
  current: []
};
exports.cache = cache;

var resetCache = function resetCache() {
  cache.current = [];
};

exports.resetCache = resetCache;

var disableCache = function disableCache() {
  cache.current = null;
};

exports.disableCache = disableCache;

var create = function create(block) {
  var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var mixed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var subs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var settings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : defaultSettings;

  if (cache.current) {
    var incache = cache.current.find(function (oldArgs) {
      return block === oldArgs.block && element === oldArgs.element && (0, _shallowequal.default)(modifier, oldArgs.modifier) && (0, _shallowequal.default)(mixed, oldArgs.mixed) && (0, _shallowequal.default)(subs, oldArgs.subs) && (0, _shallowequal.default)(settings, oldArgs.settings);
    });

    if (incache) {
      return incache;
    }
  }

  var newInstance = new Block(block, element, modifier, mixed, subs, settings);
  cache.current && cache.current.push(newInstance);
  return newInstance;
};

exports.create = create;

var coalesce = function coalesce() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return args.find(function (arg) {
    return arg !== void 0;
  });
};

var Block =
/*#__PURE__*/
function () {
  function Block(block) {
    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var mixed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var subs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    var settings = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : defaultSettings;

    _classCallCheck(this, Block);

    if (!block) {
      throw new Error('A block must be named');
    }

    this.block = block;
    this.element = element;
    this.modifier = modifier;
    this.mixed = mixed;
    this.subs = subs;
    this.settings = _objectSpread({}, defaultSettings, settings); // We probably want to use a getter but compat and all

    this.s = this.generate();
  }

  _createClass(Block, [{
    key: "e",
    value: function e(element) {
      if (this.element) {
        throw new Error("".concat(this, " has already an element. Can set ").concat(element));
      }

      return this.copy({
        element: element
      });
    }
  }, {
    key: "m",
    value: function m(modifier) {
      return this.copy({
        modifier: _objectSpread({}, this.modifier, modifier || {}),
        mixed: this.mixed.map(function (b) {
          return b.m(modifier);
        })
      });
    }
  }, {
    key: "sub",
    value: function sub() {
      for (var _len2 = arguments.length, subs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        subs[_key2] = arguments[_key2];
      }

      return this.copy({
        subs: subs.join(' ').split(' ')
      });
    }
  }, {
    key: "mix",
    value: function mix() {
      for (var _len3 = arguments.length, blocks = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        blocks[_key3] = arguments[_key3];
      }

      return this.copy({
        mixed: _toConsumableArray(this.mixed).concat(_toConsumableArray(blocks.map(function (blockOrString) {
          return typeof blockOrString === 'string' ? create(blockOrString) : blockOrString;
        }).filter(function (i) {
          return i;
        })))
      });
    }
  }, {
    key: "copy",
    value: function copy(_ref) {
      var block = _ref.block,
          element = _ref.element,
          modifier = _ref.modifier,
          mixed = _ref.mixed,
          subs = _ref.subs,
          settings = _ref.settings;
      return create(coalesce(block, this.block), coalesce(element, this.element), _objectSpread({}, coalesce(modifier, this.modifier)), _toConsumableArray(coalesce(mixed, this.mixed)), _toConsumableArray(coalesce(subs, this.subs)), _objectSpread({}, coalesce(settings, this.settings)));
    }
  }, {
    key: "generate",
    value: function generate() {
      var _this = this;

      var bem = "".concat(this.settings.namespace).concat(this.block).concat(this.element ? "".concat(this.settings.elementDelimiter).concat(this.element) : '');
      return [bem].concat(Object.entries(this.modifier).map(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            key = _ref3[0],
            val = _ref3[1];

        if (val === true) {
          return "".concat(bem).concat(_this.settings.modifierDelimiter).concat(key);
        } else if (val || val === 0) {
          return "".concat(bem).concat(_this.settings.modifierDelimiter).concat(key).concat(_this.settings.modifierValueDelimiter).concat(val);
        }
      })).filter(function (i) {
        return i;
      }).concat(this.mixed.map(function (mixed) {
        return mixed.s;
      })).join(' ').split(' ').reduce(function (x, y) {
        return x.includes(y) ? x : _toConsumableArray(x).concat([y]);
      }, []).filter(function (x) {
        return !_this.subs.includes(x);
      }).join(' ');
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.s;
    }
  }]);

  return Block;
}();

exports.Block = Block;

var wrapFunction = function wrapFunction(fun, name, args) {
  var wrapped = function wrapped() {
    for (var _len4 = arguments.length, fargs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fargs[_key4] = arguments[_key4];
    }

    // eslint-disable-next-line no-invalid-this
    return fun.apply(this, [create.apply(void 0, [name].concat(_toConsumableArray(args)))].concat(fargs));
  }; // Try to set name on function (might crash on all browsers)


  try {
    Object.defineProperty(wrapped, 'name', {
      value: name
    });
  } catch (e) {// pass
  }

  return wrapped;
};

exports.wrapFunction = wrapFunction;

var wrapClass = function wrapClass(fun, name, args) {
  var b = create.apply(void 0, [name].concat(_toConsumableArray(args)));
  fun.prototype.b = b;
  var render = fun.prototype.render;

  fun.prototype.render = function () {
    for (var _len5 = arguments.length, cargs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      cargs[_key5] = arguments[_key5];
    }

    return render.apply(this, [b].concat(cargs));
  };

  return fun;
};

exports.wrapClass = wrapClass;

var block = function block() {
  var fun = null,
      name = null,
      extra = [];

  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  if (args.length > 1 && typeof args[0] == 'string' && typeof args[1] == 'function') {
    ;
    name = args[0];
    fun = args[1];
    extra = args.slice(2);
  } else if (args.length && typeof args[0] == 'function') {
    ;
    fun = args[0];
    extra = args.slice(1);
    name = fun.displayName || fun.name || 'anonymous';
  }

  if (fun) {
    if (fun.prototype && fun.prototype.hasOwnProperty('render')) {
      return wrapClass(fun, name, extra);
    }

    return wrapFunction(fun, name, extra);
  }

  return create.apply(void 0, args);
};

var blockMaker = function blockMaker(settings) {
  return function () {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }

    args[5] = _objectSpread({}, args[5] || {}, settings);
    return block.apply(void 0, args);
  };
};

exports.blockMaker = blockMaker;
var _default = block;
exports.default = _default;